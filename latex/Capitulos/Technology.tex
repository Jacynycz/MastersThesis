\chapter{Methodology \& Technology}

\begin{FraseCelebre}
  \begin{Frase}
    The needs of the many outweigh the needs of the few
  \end{Frase}
  \begin{Fuente}
    Spock - The Wrath of Khan
  \end{Fuente}
\end{FraseCelebre}

\section{Methodology}
The idea of this project came up in a Hackathon in September 2017. We were a
group of 4 developers with one month to create an idea and a small prototype to
implement using blockchain technologies.

To give birth to the idea of a decentralized publication system for open science
we used agile methodologies.


\subsection{Brainstorming}

Brainstorming was born as a method to increase creativity in groups and
organizations. There are only few rules on this method: do not criticize any of
the given ideas, quantity is desired over quality, try to combine suggested
ideas and give all the ideas that come to mind, no matter if they are possible
or not~\cite{osborn1953applied}.

This method is used nowadays in companies and work groups as part of the process
of the creatfile uploadsion of a product, although there are some critics about
brainstorming and sometimes instead of encouragind creativity, inhibits
it~\cite{sutton1996brainstorming,mullen1991productivity}

Leaving apart these problems, we decided to make a brainstorming session to
define what we were going to do. Many ideas emerged and were capture into a
white board without discrimination, no matter how hard or easy to implement they
were.

After saying enough ideas to fill the board we filtered the ones that were
impossible to achieve. Then, each one voted the best three, making a ranking of
the 3-4 best projects to start working on. So me of the ideas were creating a
distributed \emp{wikipedia} with governance models, an application to contact
people from minority groups in countries where they are persecuted collectives,
a distributed and community driven NGO, and a crowdfunding platform for
\emph{whisteblowers}.

Finally we decided to create an approach to a distributed platform for open
science.

\subsection{Value proposition canvas}

\figura{vpc.jpg}{width=0.9\linewidth}{vpcimage}{Image of the value proposition
  canvas after the session}

A value proposition canvas is a tool to create, design and implement a product
idea. Is commonly used by businesses and entrepreneurs to find the balance
between customer profile and product design, but there are other cases of use
for this tool outside business
scope~\cite{pokorna2015value,meertens2012mapping}.

The process is divided in two parts, customer profile and value map, each of
these divided in other three parts:~\cite{osterwalder2014value}:

\begin{itemize}
\item \textbf{Customer profile:} This step is to identify the profile of the
  final user of the platform. This section is divided in three parts: 1)
  \emph{Customer jobs:} things the customer are trying to get done, 2)
  \emph{Customer pains:} undesired costs and situations, 3) \emph{Customer
    gains:} benefits, social gains and cost savings expected.
\item \textbf{Value Map:} This section is about what the final product has to
  have and what does not, and its also divided in: 1) \emph{Product and
    services:} which products and services are offered that help the customer
  get a job done, 2) \emph{Pain relievers:} how the customer pains are going to
  be alleviated, 3) \emph{Gain creators:} how the products and services create
  customer gains
\end{itemize}

We decided to use this methodology for the definition of the final platform,
since it established the general development framework of the application.

\subsection{Agile methodologies}
Traditional software development methodologies are being eclipsed by new light
or agile methodologies. These methodologies are characterized by continuous
integration, iterative development and the ability to assume changes in business
requirements~\cite{boehm2005management,livermore2008factors}.

One of the most popular is known as Extreme
Programming~\cite{lindstrom2004extreme} based on a series of basic concepts when
carrying out the development of a program: code simplicity and rapid
prototyping, continuous customer communication with the development team,
responsibility of the code of all the members of the group, short and quick
meetings, refactoring and continuous integration~\cite{theunissen2005search}.

Another well-known method within agile methodologies is
scrum~\cite{rising2000scrum}, which uses two-week frameworks to perform
development sprints and planning meetings. The use of these methodologies allows
developers to create better quality software in shorter periods of time and are
designed for small teams from three to nine developers.

I used these two methodologies to develop the platform that we were defining.
Every Saturday we had a weekly meeting where we were adding or removing
functionality to the platform. Extreme programming allowed me to meet design
demands without sacrificing development time. At the end of each session, we
planned the whole week and set the date for the next meeting.

\section{Technology}
\label{tech}

The proposed system relies upon two emerging distributed technologies. On the
one hand, the Blockchain~\cite{buterin2014ethereum} provides a public
decentralized ledger to record the system's interactions. On the other hand,
IPFS~\cite{benet_ipfs-content_2014} is a distributed file system to store all
the papers and reviews sent to the platform. This ensures that all the
information is persistent, free and accessible, and does not rely on a
centralized server.

% -------------------------------------------------------------------
\subsection{IPFS}
% -------------------------------------------------------------------
\label{tech:sec:ipfs}
IPFS stands for Interplanetary File System. It is a peer-to-peer file-sharing
protocol that uses a cryptographic hashes to store files in a distributed
network. IPFS works very similar to HTTP protocol but in a BitTorrent way. It
can be seen as a giant git repository where everyone can store, share and
exchange files\cite{benet2014ipfs}.

IPFS merges four main ideas: Distributed Hash Tables, BitTorrent, Git and
Self-Certified Systems.

\subsubsection{Distributed Hash Tables}
\label{tech:sec:ipfs:dht}
A distributed hash table(\emph{DHT}) is a decentralized structure that works
very similar to a hash table. Hash tables are used to identify items in a
database. The table performs simple mathematical operations generating a random
string called hash. The hash acts as a pointer that directs to the data, this
allows the user to find data directly instead of looking through the entire
database\cite{kaluszka2010distributed}.

In a distributed hash table, any node can use a hash as a key to retrieve data.
This system includes a data structure called ``keyspace'' that is a set of all
possible keys, which is split up across the nodes in the system. The mapping of
the keys is made by another function that describes the distance from one key to
another. All the nodes have and identifier and a set of identifiers pointing to
all its neighbors nodes. If a node is removed from the network, only a small
portion of the data must be recovered by other
nodes\cite{kaluszka2010distributed}.

This system makes \emph{DHTs} scalable, fast and robust. It is used by
frameworks such as Tapestry \cite{zhao2004tapestry}, Chord
\cite{stoica2001chord}, Kelips \cite{gupta2003kelips}, Kademlia
\cite{maymounkov2002kademlia} and IPFS \cite{benet2014ipfs}. These platforms are
similar in cost and performance if they are tested in a large enough network.
They behave very fast when it comes to searching for a key through massive
networks of nodes\cite{li2004comparing}, that's why it is used by IPFS to create
its distributed file system.

\subsubsection{BitTorrent - File sharing}
\label{tech:sec:ipfs:bt}
BitTorrent \cite{cohen2003incentives} is a P2P file sharing system used
worldwide. In this system, files are divides into very small chucks of data, and
are shared in a peer-to-peer network. Each peer aims to maximize its download
rate by connecting to low latency peers. In BitTorrent's network, peers with
high upload rate will get higher download rate, so the key is balancing the
network bandwidth between downloading and uploading
files\cite{pouwelse2005bittorrent}.

IPFS uses three main features from BitTorrent's protocol\cite{benet2014ipfs}:
\begin{itemize}
\item BitTorrent's data exchange protocol rewards nodes who contribute to the
  network, and punishes the ones who don't.
\item BitTorrent tracks the availability of file chunks, sending the rarest
  first rather than sending the most common ones.
\item IPFS uses PropShare\cite{levin2008bittorrent} bandwidth allocation
  strategy to improve BitTorrent's behavior facing exploitable scenarios.
\end{itemize}

\subsubsection{Git - Version control system}
\label{tech:sec:ipfs:git}
Git is a distributed version control system (\emph{DVCS})\cite{torvalds2010git}.
Git was born in 2005 when the development process of the Linux kernel lost its
version control system. The Linux kernel is one of the biggest free software
projects nowadays, it has a great team of developers behind and the code usually
changes very frequently. In 2002 the team used BitKeeper as VCS since they had a
free license. But in 2005 when this license was over, Linus Torvalds decided to
develop his own VCS\cite{spinellis2005version}.

Git was designed to be scalable and distributed, and the most important factors
that IPFS inherits from Git are: \cite{benet2014ipfs}:

\begin{itemize}
\item Git implements a Merkle Directed Acyclic Graph
  \cite{bleichenbacher1994directed}, an object that reflects changes in a file
  system in a distributed way.
\item Objects are identified by the cryptographic hash of their contents.
\item Version changes only update preferences and add objects. To broadcast
  version changes, git only needs to transfer the new objects and update the
  remote references.
\end{itemize}

\subsubsection{Self-Certified File Systems}
\label{tech:sec:ipfs:scfs}

A self-certified file system (\emph{SCFS}) is a secure file system that avoids
internal key management, using public keys to map file names, making
self-certifying pathnames. Key management occurs outside the system, letting the
user choose the desired procedure to generate file
names~\cite{mazieres2000self}.

The name of an self-certified file system assure its server. Users can verify
the public key offered by a \emph{SCFS} server and negotiate a shared secret to
secure all traffic.

IPFS tries to connect these ideas into a cohesive, trustful and decentralized
file system. It is build on top of a peer-to-peer network, so no nodes are
privileged, and all of those store IPFS objects in local storage. These objects
represent files or other data structures. \todo{terminar explicar IPFS}

\subsection{Ethereum}
\label{tech:sec:ethereum}
%

Ethereum~\cite{buterin2014ethereum} is a very novel technology that allows the
creation of distributed applications that run in an arbitrary large and
trust-less network of nodes. Ethereum's strength rely on three main concepts:
blockchain, smart contract and transactions.

\subsubsection{Blockchain}
\label{tech:sec:ethereum:bc}
In the decade of the 80s and the 90s, decentralized forms of payment began to
appear, such as ecash~\cite{digicash} that offered a currency with a high level
of privacy; It was then that the concept of ``anonymous electronic money'' began
to emerge.

Wei Dai in 1998 published his proposal for electronic money called
B-money~\cite{bmoney} and from this idea, other proposals have emerged such as
Bit gold~\cite{bitgold}, improving the implementation of a cryptocurrency using
RPOW~\cite{finney2005rpow}, an extension of the Hashcash work test
system~\cite{back2002hashcash}.

In 2009, the idea of a decentralized currency first emerged, when Satoshi
Nakamoto published the first version of Bitcoin~\cite{nakamoto2008bitcoin}. The
purpose of this currency was to create a fully decentralized electronic payment
system, using cryptographic tests instead of trust through a concept called
proof of work (\emph{POW}).

All monetary transactions of the system are stored in a data block until
reaching a specific size. The idea of \emph{POW} is to add a random number
(called ``nonce'') to that data so that when performing a hash function of the
whole block, it has a certain number of leading zeros. Once a block is created,
it is used as reference to the next block of data, adding the hash of the
previous block to the next one. This system is called the
blockchain~\cite{antonopoulos2014mastering} (see
figure~\ref{tech:sec:eth:bc:diagram}).

\figura{blockchain.png}{width=0.6\linewidth}{tech:sec:eth:bc:diagram}{Blockchain
  representation diagram}

All the nodes compete to find the next block, because when one of them manages
to find the nonce to create the hash with leading zeros, notifies it to all the
nodes of the network and gains 12.5 bitcoins~\cite{barber2012bitter}.

This system makes it practically impossible to falsify a transaction in the
blockchain, since the minimum change would cause an totally different hash from
the blockchains of the other nodes, provoking a desyncronization to the
peer-to-peer network. However, this system is still vulnerable to attacks aimed
at specific users, such as man in the middle attacks~\cite{moore2013beware}.

Ethereum uses this technology, not only for monetary exchanges, but for the
execution of small fragments of code called ``smart contracts''.

\subsubsection{Smart Contracts}
\label{tech:sec:ethereum:sm}
\figura{cryptomap.png}{width=0.7\linewidth}{criptomap}{Existing cryptocurrencies
  represented by purchase-sale volume}

Ethereum was born inspired by the Bitcoin concept to offer any user a tool to
develop decentralized and secure applications in a simple
way~\cite{buterin2014ethereum}. These applications are called ``smart
contracts'' and are written in the Ethereum's blockchain.

Ethereum's cryptocurrency is called ``ETH'' and not only works like Bitcoin, to
exchange money between users, but to \emph{fuel} the smart contracts' execution,
running its source code for a small amount of ETH.

Smart contracts are written in a programming language called
Solidity\footnote{http://solidity.readthedocs.io/en/develop/} provided by the
Ethereum's developers. This language is called contract-oriented and it was
influenced by C++, Python and JavaScript. Solidity offers the possibility to
create a wide range of decentralized applications in the blockchain in which
users do not have to trust a centralized organization.

These contracts also have the capacity to store an transfer money, making them
the perfect tool to implement a wide range of decentralized applications like:
gambling games~\cite{piasecki2016gaming}, voting
systems~\cite{mccorry2017smart}, crowdfunding~\cite{jacynycz2016betfunding},
prediction markets~\cite{peterson2015augur}, transparency
systems~\cite{bonneau2016ethiks} and so on. Today it is the most exchanged
currency within cryptocurrencies (see
figure~\ref{criptomap}~\cite{cryptocompare}).

Smart contracts offer us a framework to design distributed platforms like the
one proposed in this work, in which all transactions that interact with the
scientific publication process can be cryptographically signed (see
section~\ref{plat:trans}).

\subsubsection{Accounts and Transactions}
An address in ethereum is a 32-byte string that symbolizes a person's account or
an smart contract:
\begin{itemize}
\item \textbf{Personal accounts:} These are the accounts of the users who want
  to interact with the Ethereum network. Each one has its address and a balance.
\item \textbf{Contract accounts:} A smart contract also is identified by an
  Ethereum address. It contains the source code, a balance with the available
  money, and its own internal memory where it saves all the contract's
  information.
\end{itemize}

In this way, users and contract behave very similar in the blockchain, and to
communicate these addresses, Ethereum uses transactions.

Smart contracts behavior is transaction-based~\cite{wood2014ethereum}. once a
contract is deployed in the blockchain, users (or other contracts) may send
transactions to run its code. Each transaction has a payload, containing the
data required to execute the desired part of the contract. This execution has a
fee that users have to pay to the network based on how complex is the code they
want to run.

Ethereum's transaction-based smart contracts have changed the paradigm of modern
software development, since the priority when developing a smart contract is to
reduce the transaction costs of each interaction~\cite{delmolino2016step}.

\figura{transaction.png}{width=0.9\linewidth}{tech:sec:eth:tx:diagram}{Blockchain's
  state change through transactions}

\subsection{Remix}
\figura{remix.png}{width=0.95\linewidth}{tech:sec:remix:sc}{Remix smart contract
  web compiler}Remix\footnote{https://remix.ethereum.org/} es un compilador online de contratos
inteligentes diseñado por la comunidad de Ethereum que permite crear, compilar y
desplegar contratos inteligentes tanto en una testnet como en la blockchain.

Este compilador ofrece la posibilidad de poder probar los contratos a través de
una máquina virtual que simula la blockchain de
Ethereum~\cite{hildenbrandt2017kevm}. Tras desplegar un contrato a través de
Remix, la plataforma genera elementos HTML que simulan botones de interacción
con el código, sin tener que desarrollar un frontend para probar las funciones
de este.

Además Remix ofrece un debugger para poder seguir el proceso de ejecución de una
transacción, un estimador del gas necesario para poder realizarla, un analizador
de código para detectar posibles vulnerabilidades y un sistema de exportación
para generar ABIs (ver seccion \ref{jsmm}).

Esta herramienta facilita mucho el proceso de desarrollo, ya que se pueden
probar diferentes implementaciones realizando minimos cambios en el código y sin
tener que instalar ningun programa (ver figura~\ref{tech:sec:remix:sc}).

\subsection{JavaScript and Metamask}
\label{jsmm}
Ethereum dispone de un sistema para conectar usuarios a la blockchain a través
de los navegadores web. Existen varias formas de poder conectarse: mediante
navegadores especiales como AlethZero o Mist, o mediante la utilización de
Metamask.

Metamask es una extensión de los navegadores web más comunes (como Firefox o
Chrome) que permite al usuario conectarse tanto a la red de Ethereum como a una
testnet personalizada. Contiene los mecanismos necesarios para poder realizar
transacciones y comunicarse con los contratos inteligentes que están en la
blockchain. Para poder utilzarlo simplemente hay que instalar un pequeño
programa en el navegador y disponer de una dirección con fondos para poder
realizar estas transacciones.

JavaScript se utiliza para conectar con la dirección de un contrato inteligente
y poder llamar a funciones específicas de este. Para ello el JavaScript ha de
disponer de dos datos importantes:

\begin{itemize}
\item \textbf{La dirección del contrato:} Al cargar la página web que se conecta
  al contrato se debe disponer de la dirección de Ethereum en el que está
  alojado, ya que para todas las interacciones con la plataforma se han de
  realizar transacciones a dicha dirección.
\item \textbf{ABI del contrato:} ABI significa Aplication Biary Interface y es
  una estructura de datos en la que se encuentran todas las funciones a las que
  se puede llamar en un contrato inteligente. Es la forma que tiene javascript
  de poder construir las transacciones para llamar a dichas funciones. La
  generación del ABI suele ser automática cuando se crea un contrato
  inteligente.
\end{itemize}

Estas dos tecnologías son las utilizadas para realizar pruebas en el contrato
inteligente a través de un HTML personalizado que simulaba la plataforma.
Tniendo en cuenta como serían las interacciones de todos los usuarios de la
plataforma si migraran de los sistemas actuales.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
