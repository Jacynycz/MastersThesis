\chapter{Methodology \& Technology}

\begin{FraseCelebre}
  \begin{Frase}
    The needs of the many outweigh the needs of the few
  \end{Frase}
  \begin{Fuente}
    Spock - The Wrath of Khan
  \end{Fuente}
\end{FraseCelebre}

\section{Methodology}
The idea of this project came up in a Hackathon in September 2017. We were a
group of 4 developers with one month to create an idea and a small prototype to
implement using blockchain technologies.

To give birth to the idea of a decentralized publication system for open science
we used agile methodologies.


\subsection{Brainstorming}

Brainstorming was born as a method to increase creativity in groups and
organizations. There are only few rules on this method: do not criticize any of
the given ideas, quantity is desired over quality, try to combine suggested
ideas and give all the ideas that come to mind, no matter if they are possible
or not~\cite{osborn1953applied}.

This method is used nowadays in companies and work groups as part of the process
of the creatfile uploadsion of a product, although there are some critics about
brainstorming and sometimes instead of encouragind creativity, inhibits
it~\cite{sutton1996brainstorming,mullen1991productivity}

Leaving apart these problems, we decided to make a brainstorming session to
define what we were going to do. Many ideas emerged and were capture into a
white board without discrimination, no matter hukow hard or easy to implement
they were.

After saying enough ideas to fill the board we filtered the ones that were
impossible to achieve. Then, each one voted the best three, making a ranking of
the 3-4 best projects to start working on. Some of the ideas we came up to were
creating a distributed \emp{wikipedia} with governance models, an application to
contact people from minority groups in countries where they are persecuted
collectives, a distributed and community driven NGO, and a crowdfunding platform
for \emph{whisteblowers}.

Finally we decided to create an approach to a distributed platform for open
science which we initially called Alexandria, in honor of Alexandra Elbakyan,
the creator of Sci-hub. But we finally changed the name of the project to
Decentralized Science because there were a similar project about distributed
system for media files using blockchain with the same
name\footnote{https://www.alexandria.io/}.

\subsection{Value proposition canvas}

\figura{vpc.jpg}{width=0.9\linewidth}{vpcimage}{Image of the value proposition
  canvas after the session}

A value proposition canvas is a tool to create, design and implement a product
idea. Is commonly used by businesses and entrepreneurs to find the balance
between customer profile and product design, but there are other cases of use
for this tool outside business
scope~\cite{pokorna2015value,meertens2012mapping}.

The process is divided in two parts, customer profile and value map, each of
these divided in other three parts:~\cite{osterwalder2014value}:

\begin{itemize}
\item \textbf{Customer profile:} This step is to identify the profile of the
  final user of the platform. This section is divided in three parts: 1)
  \emph{Customer jobs:} things the customer are trying to get done, 2)
  \emph{Customer pains:} undesired costs and situations, 3) \emph{Customer
    gains:} benefits, social gains and cost savings expected.
\item \textbf{Value Map:} This section is about what the final product has to
  have and what does not, and its also divided in: 1) \emph{Product and
    services:} which products and services are offered that help the customer
  get a job done, 2) \emph{Pain relievers:} how the customer pains are going to
  be alleviated, 3) \emph{Gain creators:} how the products and services create
  customer gains
\end{itemize}

We decided to use this methodology for the definition of the final platform,
since it established the general development framework of the application.

\subsection{Agile methodologies}
Traditional software development methodologies are being eclipsed by new light
or agile methodologies. These methodologies are characterized by continuous
integration, iterative development and the ability to assume changes in business
requirements~\cite{boehm2005management,livermore2008factors}.

One of the most popular is known as Extreme
Programming~\cite{lindstrom2004extreme} based on a series of basic concepts when
carrying out the development of a program: code simplicity and rapid
prototyping, continuous customer communication with the development team,
responsibility of the code of all the members of the group, short and quick
meetings, refactoring and continuous integration~\cite{theunissen2005search}.

Another well-known method within agile methodologies is
scrum~\cite{rising2000scrum}, which uses two-week frameworks to perform
development sprints and planning meetings. The use of these methodologies allows
developers to create better quality software in shorter periods of time and are
designed for small teams from three to nine developers.

I used these two methodologies to develop the platform that we were defining.
Every Saturday we had a weekly meeting where we were adding or removing
functionality to the platform. Extreme programming allowed me to meet design
demands without sacrificing development time. At the end of each session, we
planned the whole week and set the date for the next meeting.

\section{Technology}
\label{tech}

The proposed system relies upon two emerging distributed technologies. On the
one hand, the Blockchain~\cite{buterin2014ethereum} provides a public
decentralized ledger to record the system's interactions. On the other hand,
IPFS~\cite{benet_ipfs-content_2014} is a distributed file system to store all
the papers and reviews sent to the platform. This ensures that all the
information is persistent, free and accessible, and does not rely on a
centralized server.

% -------------------------------------------------------------------
\subsection{IPFS}
% -------------------------------------------------------------------
\label{tech:sec:ipfs}
IPFS stands for Interplanetary File System. It is a peer-to-peer file-sharing
protocol that uses a cryptographic hashes to store files in a distributed
network. IPFS works very similar to HTTP protocol but in a BitTorrent way. It
can be seen as a giant git repository where everyone can store, share and
exchange files\cite{benet2014ipfs}.

IPFS merges four main ideas: Distributed Hash Tables, BitTorrent, Git and
Self-Certified Systems.

\subsubsection*{Distributed Hash Tables}
\label{tech:sec:ipfs:dht}
A distributed hash table(\emph{DHT}) is a decentralized structure that works
very similar to a hash table. Hash tables are used to identify items in a
database. The table performs simple mathematical operations generating a random
string called hash. The hash acts as a pointer that directs to the data, this
allows the user to find data directly instead of looking through the entire
database\cite{kaluszka2010distributed}.

In a distributed hash table, any node can use a hash as a key to retrieve data.
This system includes a data structure called ``keyspace'' that is a set of all
possible keys, which is split up across the nodes in the system. The mapping of
the keys is made by another function that describes the distance from one key to
another. All the nodes have and identifier and a set of identifiers pointing to
all its neighbors nodes. If a node is removed from the network, only a small
portion of the data must be recovered by other
nodes\cite{kaluszka2010distributed}.

This system makes \emph{DHTs} scalable, fast and robust. It is used by
frameworks such as Tapestry \cite{zhao2004tapestry}, Chord
\cite{stoica2001chord}, Kelips \cite{gupta2003kelips}, Kademlia
\cite{maymounkov2002kademlia} and IPFS \cite{benet2014ipfs}. These platforms are
similar in cost and performance if they are tested in a large enough network.
They behave very fast when it comes to searching for a key through massive
networks of nodes\cite{li2004comparing}, that's why it is used by IPFS to create
its distributed file system.

\subsubsection*{BitTorrent - File sharing}
\label{tech:sec:ipfs:bt}
BitTorrent \cite{cohen2003incentives} is a P2P file sharing system used
worldwide. In this system, files are divides into very small chucks of data, and
are shared in a peer-to-peer network. Each peer aims to maximize its download
rate by connecting to low latency peers. In BitTorrent's network, peers with
high upload rate will get higher download rate, so the key is balancing the
network bandwidth between downloading and uploading
files\cite{pouwelse2005bittorrent}.

IPFS uses three main features from BitTorrent's protocol\cite{benet2014ipfs}:
\begin{itemize}
\item BitTorrent's data exchange protocol rewards nodes who contribute to the
  network, and punishes the ones who don't.
\item BitTorrent tracks the availability of file chunks, sending the rarest
  first rather than sending the most common ones.
\item IPFS uses PropShare\cite{levin2008bittorrent} bandwidth allocation
  strategy to improve BitTorrent's behavior facing exploitable scenarios.
\end{itemize}

\subsubsection*{Git - Version control system}
\label{tech:sec:ipfs:git}
Git is a distributed version control system (\emph{DVCS})\cite{torvalds2010git}.
Git was born in 2005 when the development process of the Linux kernel lost its
version control system. The Linux kernel is one of the biggest free software
projects nowadays, it has a great team of developers behind and the code usually
changes very frequently. In 2002 the team used BitKeeper as VCS since they had a
free license. But in 2005 when this license was over, Linus Torvalds decided to
develop his own VCS\cite{spinellis2005version}.

Git was designed to be scalable and distributed, and the most important factors
that IPFS inherits from Git are: \cite{benet2014ipfs}:

\begin{itemize}
\item Git implements a Merkle Directed Acyclic Graph
  \cite{bleichenbacher1994directed}, an object that reflects changes in a file
  system in a distributed way.
\item Objects are identified by the cryptographic hash of their contents.
\item Version changes only update preferences and add objects. To broadcast
  version changes, git only needs to transfer the new objects and update the
  remote references.
\end{itemize}

\subsubsection*{Self-Certified File Systems}
\label{tech:sec:ipfs:scfs}

A self-certified file system (\emph{SCFS}) is a secure file system that avoids
internal key management, using public keys to map file names, making
self-certifying pathnames. Key management occurs outside the system, letting the
user choose the desired procedure to generate file
names~\cite{mazieres2000self}.

The name of an self-certified file system assure its server. Users can verify
the public key offered by a \emph{SCFS} server and negotiate a shared secret to
secure all traffic.

IPFS tries to connect these ideas into a cohesive, trustful and decentralized
file system. It is build on top of a peer-to-peer network, so no nodes are
privileged, and all of those store IPFS objects in local storage. These objects
represent files or other data structures.

\subsubsection*{IPFS on Decentralized Science}

IPFS proporciona un sistema de archivos robusto, distribuido y seguro, en el que
los archivos están formados criptográficamente por el hash de los datos. Este
hash se comporta como un enlace dentro de la red de IPFS que permite identificar
y recuperar el archivo gracias a las tecnologías que se han mencionado en los
apartados anteriores.

Esta característica implica que dos archivos idénticos se identifiquen con el
mismo hash, eliminando duplicados de manera fácil y rápida.

En Decentralized Science utilizamos esta tecnología para almacenar todos los
archivos de la plataforma ya que nos permite tener un sistema de archivos
descentralizado, sin necesidad de un servidor, robusto y persistente. Estas
características hacen que la plataforma sea resistente tanto a censura como a
prohibición, ya que IPFS funciona sobre una red de miles de nodos.

\subsection{Ethereum}
\label{tech:sec:ethereum}
Como se ha visto en la sección~\ref{tb:eth}, Ethereum es una tecnología que
permite crear aplicaciones totalmente descentralizadas y autónomas. Estas
aplicaciones son subidas a la cadena de bloques de Ethereum por lo que no es
necesario disponer de ningun servidor para ejecutarlas o comunicarse con ellas.

Con Ethereum e IPFS, Decentralized Science es una plataforma 100\% distribuida,
libre y gratuita\footnote{Las interaciones con la plataforma pueden tener coste
  de transacción dentro de la red de Ethereum (ver sección~\ref{sec})
  \nopagebreak} para todos los usuarios.


\subsection{Remix}
\figura{remix.png}{width=0.95\linewidth}{tech:sec:remix:sc}{Remix smart contract
  web compiler}Remix\footnote{https://remix.ethereum.org/} is an online smart
contract web compiler designed by the Ethereum community that allows users
create, compile and deploy contracts both in a test net or in the Ethereum's
blockchain.

This compiler offers the possibility to try the functionality of the contracts
through a virtual machine that simulates the blockchain's behavior called EVM
(\emph{Ethereum Virtual Machine})~\cite{hildenbrandt2017kevm}. When deploying a
contract with this platform, a series of HTML elements are generated, simulating
a real deployment and allowing developers to interact with the contract, without
the need of developing a frontend to try the contract behavior.

Remix also has a series of interesting features: a debugger to follow the
execution process of a transaction, a gas calculator that estimates the gas cost
of each transaction, a code analizer to detect possible vulnerabilities and an
ABI export system (see section \ref{jsmm}).

This tool facilitate the process of smart contracts developments, since the web
service allows to try different implementations of the same contract doing only
small changes, without the need of installing any software (see figure
~\ref{tech:sec:remix:sc}).

\subsection{Testrpc}
\label{testrpc}
\figura{testrpc.png}{width=0.7\linewidth}{testrpc:sc}{Transactions mined by
  testrpc in a test network} Testrpc is a Node.js based Ethereum client for
testing a development. It simulates an Ethereum client behavior using the
ethereum.js library. Once installed throug \code{npm}, it can lauched through
the linux terminal with the command \code{testrpc} and offers the developers a
series of interesting features:

\begin{itemize}
  \itbf{Simulate accounts:}
  Testrpc\footnote{https://www.npmjs.com/package/ethereumjs-testrpc} default
  command launches 5 accounts, but it offers the possibility to add as many as
  needed with the option ``--accounts'', this allowed this project to simulate
  the interaction of 1000 accounts communicating with the contracts''. Example:
  \code{testrpc -a 1000}

  \itbf{View transactions:} Once testrpc is lauched, developers can see through
  the console all the transactions made with the blockchain in a user-frendly
  way. It also has a gas estimator to calculate the price of each transaction
  (see figure \ref{testrpc:sc}).

  \itbf{Create test net:} Testrpc creates a test net through the port 8545. Any
  user in the internet using Metamask (see section \ref{jsmm}) can connect to
  this test net and interact with the contracts deployed.

  \itbf{Give ETH to an existing account:} If an user already has an Ethereum
  account and wants to connect a testrpc node, the administrator can assign ETH
  to that account to allow the user do transactions in the test net.
\end{itemize}

The main difference between a testrpc network and the Ethereum network is that
testrpc creates one block for each transaction, making a small block size
compared to the Ethereum network, and preventing the gas estimator being
accurate.

\subsection{JavaScript and Metamask}
\label{jsmm}
Ethereum smart contract interaction is usually a web application that connects
to its address, and it has systems to connect users to the blockchain through
web browsers. There are two different ways to achieve this: the first one is to
install an specialized web browser like
AlethZero\footnote{https://github.com/ethereum/alethzero},
Mist\footnote{https://github.com/ethereum/mist} or
Brave\footnote{https://brave.com/}that connects to the blockchain automatically.
Or installing an extension like Metamask\footnote{https://metamask.io/}.


Metamask is an web browser extension (available for Chrome, Firefox, and Opera)
that allows its users to connect both to a Ethereum network or a custom test
net. It contains the mechanism needed to make transactions and communicate with
smart contracts in the blockchain. To use it, users only need to install the
extension from the Metamask homepage and configure it with an Ethereum account.
Metamask also allows the creation of new accounts, but to make transactions with
the official blockchain, it has to have enough funds.

So Metamask not only acts as bridge between a web browser and the Ethereum
network, it also works as a wallet and support Ethereum's official tokens.

JavaScript is used to connect to an smart contract address and be able to call
to specific functions of it. To do so, the JavaScript code has to have two
important data:

\begin{itemize}
\item \textbf{Ethereum's contrat address:} When the user loads the web page to
  connect to the contract, JavaScript must have the address in which it is
  stored, because all the interactions with the platform are made through
  transactions to this address.
\item \textbf{Contract's ABI:} An ABI (Application Binary Interface) is a data
  structure in which JavaScript can find all the methods a contract has. Each
  method defines its inputs, outputs, type, if its payable and a state.
  JavaScript uses this information to build the transactions to call these
  methods (see listing \ref{abi}).

\end{itemize}

This two technologies were used to test the platform proposed in this work,
using HTML and Testrpc to simulate a functional journal (see section \ref{poc})


\input{Capitulos/listing_abi.tex}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
